---
output: github_document
always_allow_html: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```
# edibble  <img src="man/figures/logo.png" align="right" alt="" width="120" />

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

## Installation

Install the development version with: 

```
# install.packages("remotes")
remotes::install_github("emitanaka/edibble")
```


## Overview

Software for constructing experimental design generally utilise: (1) functions that are specific for creating particular experimental designs (e.g. `agricolae::design.lsd()` creates a Latin Square Design) or (2) where it is general, requires an input (usually a data frame) with the initial experimental design structure (e.g. `AlgDesign::optBlock()` or most optimal designs). Both of these approaches assume that the user is well acquainted with the experimental structure and objective, but in practice these are the greatest bottleneck before even getting to think about the randomisation process. 

üí° The big idea with the edibble R-package is that you specify an experimental design by being more expressive about the experiment. The edibble code for constructing experimental design should evoke a rough idea about the experimental layout even to a layperson. 

üéØ The grand goal for the edibble project is to define the _grammar of experimental design_ and implement it. 

Take for an example, the classic split-plot design that contains 4 wholeplots with 4 sub plots within each wholeplot (so 16 subplots in total). There are 2 treatment factors: fertilizer (with levels A and B) and variety (with levels V1 and V2). Each level of the fertilizer is randomly applied to two wholeplots. Each level of variety is randomly applied to two subplots within each wholeplot. 

In edibble, we can code the above split-plot design as below. You can see it outputs a data frame (or tibble) called edibble. The name origin of `edibble` is a play on [`tibble`](https://tibble.tidyverse.org/) and can be thought of as tibble output for experimental design.

```{r split-plot}
library(edibble)

set.seed(2020) # üî•ü¶†üè†üò±

spdes <- start_design("Split-plot Design") %>% 
  set_units(wholeplot = 4,
            subplot = nested_in(wholeplot, 4)) %>% 
  set_trts(fertilizer = c("A", "B"),
           variety    = c("V1", "V2")) %>% 
  allocate_trts(fertilizer ~ wholeplot, 
                   variety ~ subplot) %>% 
  randomise_trts()
```

Above object contains the intermediate construct of an experimental design (called `edbl_nexus`). When you are ready to serve your design, you can get the table output (called `edbl_df`) by using `serve_table` as below.

```{r split-plot-table}
serve_table(spdes)
```

Once you get the rough idea of how edibble specifies design, you should be roughly be able to visualise what the experimental design layout is just from looking at the code alone. Take another example below. Can you see what the design is?

```{r rcbd, fig.height = 5, fig.width = 5}
rcbd <- start_design("RCBD") %>% 
  set_units(block = 4,
            plot  = nested_in(block, 4)) %>% 
  set_trts(fertilizer = c("A", "B"),
           variety    = c("V1", "V2")) %>% 
  allocate_trts(fertilizer:variety ~ plot) %>% 
  randomise_trts()
```

The above design is an example of a Randomised Complete Block Design. If you change the unit names from `block` to `wholeplot` and `plot` to `subplot`, it looks like the Split-plot Design, so what differs here aside from the unit names? Yes, the allocation of treatment is more restrictive in the Split-plot Design. This is one of the key benefits of using edibble to construct your experimental design; it makes you think about your experiment in bare terms.

If you have trouble understanding the layout, there are a number of considerations that are designed to help you to form a better understanding of what you have specified. I outline just a couple here with more details and explanations to come (writing takes a lot of time...).

You can see a high-level overview of the variables and its relation by using `plot` on the intermediate construct of the design.

```{r high-view, fig.height = 6, fig.width = 12}
par(mfrow = c(1, 2))
plot(rcbd)
plot(spdes)
```

If you want to see the connections in terms of the actual units, then you can change the view to a low-level view. 

```{r low-view, fig.height = 6, fig.width = 12}
par(mfrow = c(1, 2))
plot(rcbd, view = "low")
plot(spdes, view = "low")
```

The low-level view is often a bit cluttered so you may like to use the interactive version as below instead. 

```{r, eval = FALSE}
subset_levels(rcbd$graph) %>% 
  igraph::tkplot()
```

‚ö†Ô∏è Please note that edibble is currently fragile. That means that the code is likely to break when you deviate from example code. Even it it works, you should diagnose the output to make sure it did what you expected.

## Named experimental designs

While named experimental designs can be muddling to understanding the experimental structure, it is still convenient to be able to concisely describe common structures. I take a compromising approach where named experimental designs can be generated consisely using the `create_classic` function. The output contains information about the design, the code to generate the design using edibble that can be easily copy-and-pasted and the output data frame. If you want just the edibble code alone then you can just substitute it with `create_classic_code`.

```{r}
create_classic("crd", n = 30, t = 5)

create_classic_code("rcbd", t = 4, n = 40)
```

What it looks like in the terminal:

```{r, include = FALSE}
options(cli.num_colors = 256L)
options(asciicast_knitr_svg = TRUE)
asciicast::init_knitr_engine(
  startup = quote({
      library(edibble)
    }),
  echo = TRUE,
  echo_input = FALSE)
```


```{asciicast split-plot-print}
create_classic("split", t1 = 4, t2  = 2, r = 4)
```



## Related Work

The way that edibble specifies experimental design is largely novel (if I say so myself). Below are some related work.

* `DeclareDesign` for survey or sampling designs
* `designr` for balanced factorial designs with crossed and nested random and fixed effect to data frame
* `dae` for functions useful in the design and ANOVA of experiments (this is in fact powering the randomisation in edibble)
* `plotdesignr` for designing agronomic field experiments

## Code of Conduct

Please note that the edibble project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html).
By contributing to this project, you agree to abide by its terms.
